<?php
namespace UBC\LTI\Specs;

use Illuminate\Support\Facades\Log;

use Jose\Component\Signature\JWS;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Easy\JWT;
use Jose\Easy\Load;

use App\Models\AbstractLtiEntity;

use UBC\LTI\Specs\Security\Nonce;
use UBC\LTI\Utils\LtiException;
use UBC\LTI\Utils\LtiLog;
use UBC\LTI\Utils\Param;

// the JWT framework only offers easy access to the JWS claims *after* it has
// been verified, but sometimes, we need access to the claims in order to
// perform the verification. This class helps in such cases.
class JwsUtil
{
    // reject tokens that are older than this, in seconds
    public const TOKEN_OLD_AGE = Param::EXP_TIME * 10;
    // to account for a bit of clock mismatch when verifying timestamps,
    // we allow a leeway in seconds
    public const TOKEN_LEEWAY = 60;

    private LtiLog $ltiLog;
    private JWS $jws;
    private array $claims;

    public function __construct(string $jwtString, LtiLog $ltiLog)
    {
        $this->ltiLog = $ltiLog;
        try {
            $this->jws = (new CompactSerializer())->unserialize($jwtString);
        }
        catch (\Exception $e) {
            throw new LtiException($this->ltiLog->msg(
                'Unable to deserialized JWT: ' . $e->getMessage()),
                0,
                $e
            );
        }
        $this->claims = json_decode($this->jws->getPayload(), true);
    }

    // returns the given claim's value if it exists, throws an exception if it
    // doesn't. It's throwing an exception cause a claim that we want to access
    // before verification is probably required anyways.
    public function getClaim($claim): string
    {
        if (isset($this->claims[$claim])) {
            return $this->claims[$claim];
        }
        throw new LtiException(
            $this->ltiLog->msg("JWS missing param '$claim'."));
    }

    // returns key id if there is one, empty string otherwise
    // kid can't be treated as a claim because it's part of the signature header
    // kid is also an optional parameter so shouldn't throw exception
    public function getKid(): string
    {
        if (
            isset($this->jws->getSignature(0)->getProtectedHeader()[Param::KID])
        ) {
            return $this->jws->getSignature(0)->getProtectedHeader()[Param::KID];
        }
        return '';
    }

    /**
     * Return the encoded token string originally given to the constructor.
     */
    public function getToken(): string
    {
        // instead of storing the original token, I think we can just
        // reserialize it
        return (new CompactSerializer())->serialize($this->jws);
    }

    /**
     * Returns true if the given claim is present, false otherwise.
     */
    public function hasClaim($claim): bool
    {
        return isset($this->claims[$claim]);
    }

    /**
     * Verify the security of a JWS and decode it into an JWT object. You will
     * need to pass it the LTI tool or platform that created the JWS so it can
     * grab the correct RSA key needed to verify the siganture. This will also
     * require the expected value for aud and iss. There's 3 parts to the
     * security verification: signature, timestamps, and nonce.
     *
     * The $canAddNonce param tells us that since the nonce was not generated
     * by the shim itself, we should try to add it into the nonce store first
     * before checking validity.
     */
    public function verifyAndDecode(
        AbstractLtiEntity $ltiEntity,
        string $aud,
        string $iss,
        bool $canAddNonce = false
    ): JWT {
        $jwt;
        try {
            $kid = $this->getKid();
            $this->ltiLog->debug('signature verify kid: ' . $kid);
            $jwk = $ltiEntity->getKey($this->getKid());
            $this->ltiLog->debug('key table id: ' . $jwk->id);
            $jwt = Load::jws($this->getToken())
                ->algs([Param::RS256])
                ->aud($aud)
                ->iss($iss)
                ->key($jwk->public_key)
                ->run();
        } catch(\Exception $e) { // invalid signature throws a bare Exception
            throw new LtiException($this->ltiLog->msg('Invalid JWS',$e), 0, $e);
        }
        self::verifyTimestamps($jwt, $this->ltiLog);

        $nonce = $jwt->claims->get(Param::NONCE);
        if ($canAddNonce) Nonce::store($nonce);
        if (Nonce::isValid($nonce)) Nonce::used($nonce);
        else throw new LtiException($this->ltiLog->msg('Invalid nonce'));

        return $jwt;
    }

    /**
     * The JWT library we're using does not support floating point for exp,
     * nbf, iat claims. Even though the spec allows them. So for JWTs that
     * use floats for those numbers, we need to do custom validation for them.
     *
     * Note that exp and iat are required by LTI, nbf is optional.
     *
     * We should only have to use this function for validating JWTs that wasn't
     * generated by us. So for things like our own session tokens, we can just
     * use the stock facilities.
     *
     * TODO: make this a private method once we remove all static calls to it
     *
     * @throw LtiException if any of the timestamps are invalid
     */
    public static function verifyTimestamps(JWT $jwt, LtiLog $ltiLog)
    {
        $now = time();
        $exp = $jwt->claims->exp();
        if (!(is_int($exp) || is_float($exp))) {
            throw new LtiException($ltiLog->msg('exp must be numeric'));
        }
        if ($now > $exp + self::TOKEN_LEEWAY) {
            throw new LtiException($ltiLog->msg('Expired JWT'));
        }

        // Not valid if received before the iat (issued at) time
        $iat = $jwt->claims->iat();
        if (!(is_int($iat) || is_float($iat))) {
            throw new LtiException($ltiLog->msg('iat must be numeric'));
        }
        if ($iat > ($now + self::TOKEN_LEEWAY)) {
            throw new LtiException($ltiLog->msg('Back to the future JWT'));
        }

        // Not valid if it's too old. We got an old token with a valid
        // (but excessively large) expiration window that we'd prefer not to
        // validate.
        if (($now - $iat) > self::TOKEN_OLD_AGE) {
            throw new LtiException($ltiLog->msg('JWT too old'));
        }

        // Not valid if received before the nbf (not before) time
        if ($jwt->claims->has(Param::NBF)) {
            $nbf = $jwt->claims->nbf();
            if (!(is_int($nbf) || is_float($nbf))) {
                throw new LtiException($ltiLog->msg('nbf must be numeric'));
            }
            if ($nbf > ($now + self::TOKEN_LEEWAY)) {
                throw new LtiException($ltiLog->msg('JWT not yet nbf'));
            }
        }
    }
}
