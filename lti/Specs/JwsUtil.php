<?php
namespace UBC\LTI\Specs;

use Illuminate\Support\Facades\Log;

use Jose\Component\Signature\JWS;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Easy\JWT;

use UBC\LTI\Utils\LtiException;
use UBC\LTI\Utils\LtiLog;
use UBC\LTI\Utils\Param;

// the JWT framework only offers easy access to the JWS claims *after* it has
// been verified, but sometimes, we need access to the claims in order to
// perform the verification. This class helps in such cases.
class JwsUtil
{
    // reject tokens that are older than this, in seconds
    public const TOKEN_OLD_AGE = 3600;
    // to account for a bit of clock mismatch when verifying timestamps,
    // we allow a leeway in seconds
    public const TOKEN_LEEWAY = 60;

    private LtiLog $ltiLog;
    private JWS $jws;
    private array $claims;

    public function __construct(string $jwtString, LtiLog $ltiLog)
    {
        $this->ltiLog = $ltiLog;
        try {
            $this->jws = (new CompactSerializer())->unserialize($jwtString);
        }
        catch (\Exception $e) {
            throw new LtiException($this->ltiLog->msg(
                'Unable to deserialized JWT: ' . $e->getMessage()),
                0,
                $e
            );
        }
        $this->claims = json_decode($this->jws->getPayload(), true);
    }

    // returns the given claim's value if it exists, throws an exception if it
    // doesn't. It's throwing an exception cause a claim that we want to access
    // before verification is probably required anyways.
    public function getClaim($claim): string
    {
        if (isset($this->claims[$claim])) {
            return $this->claims[$claim];
        }
        throw new LtiException(
            $this->ltiLog->msg("JWS missing param '$claim'."));
    }

    // returns key id if there is one, empty string otherwise
    // kid can't be treated as a claim because it's part of the signature header
    // kid is also an optional parameter so shouldn't throw exception
    public function getKid(): string
    {
        if (
            isset($this->jws->getSignature(0)->getProtectedHeader()[Param::KID])
        ) {
            return $this->jws->getSignature(0)->getProtectedHeader()[Param::KID];
        }
        return '';
    }

    /**
     * The JWT library we're using does not support floating point for exp,
     * nbf, iat claims. Even though the spec allows them. So for JWTs that
     * use floats for those numbers, we need to do custom validation for them.
     *
     * Note that exp and iat are required by LTI, nbf is optional.
     *
     * We should only have to use this function for validating JWTs that wasn't
     * generated by us. So for things like our own session tokens, we can just
     * use the stock facilities.
     *
     * @throw LtiException if any of the timestamps are invalid
     */
    public static function verifyTimestamps(JWT $jwt, LtiLog $ltiLog)
    {
        $now = time();
        $exp = $jwt->claims->exp();
        if (!(is_int($exp) || is_float($exp))) {
            throw new LtiException($ltiLog->msg('exp must be numeric'));
        }
        if ($now > $exp + self::TOKEN_LEEWAY) {
            throw new LtiException($ltiLog->msg('Expired JWT'));
        }

        $now += self::TOKEN_LEEWAY;
        $iat = $jwt->claims->iat();
        if (!(is_int($iat) || is_float($iat))) {
            throw new LtiException($ltiLog->msg('iat must be numeric'));
        }
        if ($iat > ($now + self::TOKEN_LEEWAY)) {
            throw new LtiException($ltiLog->msg('Back to the future JWT'));
        }
        // old age should be a lot larger than the leeway, so it should be fine
        // not giving them a leeway here
        if (($now - $iat) > self::TOKEN_OLD_AGE) {
            throw new LtiException($ltiLog->msg('JWT too old'));
        }

        if ($jwt->claims->has(Param::NBF)) {
            $nbf = $jwt->claims->nbf();
            if (!(is_int($nbf) || is_float($nbf))) {
                throw new LtiException($ltiLog->msg('nbf must be numeric'));
            }
            if ($now < $nbf) {
                throw new LtiException($ltiLog->msg('JWT not yet nbf'));
            }
        }
    }
}
