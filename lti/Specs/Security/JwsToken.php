<?php
namespace UBC\LTI\Specs\Security;

use Illuminate\Support\Facades\Log;

use Jose\Component\Signature\JWS;
use Jose\Component\Signature\Serializer\CompactSerializer;
use Jose\Easy\JWT;

use App\Models\AbstractLtiEntity;

use UBC\LTI\Specs\Security\Nonce;
use UBC\LTI\Utils\JwtChecker;
use UBC\LTI\Utils\JwsUtil;
use UBC\LTI\Utils\LtiException;
use UBC\LTI\Utils\LtiLog;
use UBC\LTI\Utils\Param;

/**
 * Helps build and verify JWS tokens such as launch's 'id_token' param, deep
 * link's 'jwt' param, etc.
 */
class JwsToken
{
    private LtiLog $ltiLog;
    private JWS $jws;
    private array $claims;
    private string $token;
    private JwtChecker $checker;

    public function __construct(string $jwtString, LtiLog $ltiLog)
    {
        $this->ltiLog = $ltiLog;
        $this->token = $jwtString;
        try {
            $this->jws = (new CompactSerializer())->unserialize($jwtString);
        }
        catch (\Exception $e) {
            throw new LtiException($this->ltiLog->msg(
                'Unable to deserialized JWT: ' . $e->getMessage()),
                0,
                $e
            );
        }
        $this->claims = json_decode($this->jws->getPayload(), true);
        $this->checker = new JwtChecker($this->claims);
    }

    // returns the given claim's value if it exists, throws an exception if it
    // doesn't. It's throwing an exception cause a claim that we want to access
    // before verification is probably required anyways.
    public function getClaim($claim): mixed
    {
        if (isset($this->claims[$claim])) {
            return $this->claims[$claim];
        }
        throw new LtiException(
            $this->ltiLog->msg("JWS missing param '$claim'."));
    }

    // returns key id if there is one, empty string otherwise
    // kid can't be treated as a claim because it's part of the signature header
    // kid is also an optional parameter so shouldn't throw exception
    public function getKid(): string
    {
        if (
            isset($this->jws->getSignature(0)->getProtectedHeader()[Param::KID])
        ) {
            return $this->jws->getSignature(0)->getProtectedHeader()[Param::KID];
        }
        return '';
    }

    /**
     * Return the encoded token string originally given to the constructor.
     */
    public function getToken(): string
    {
        // instead of storing the original token, I think we can just
        // reserialize it
        return (new CompactSerializer())->serialize($this->jws);
    }

    /**
     * Returns true if the given claim is present, false otherwise.
     */
    public function hasClaim($claim): bool
    {
        return isset($this->claims[$claim]);
    }

    /**
     * Verify the security of a JWS and return the payload. You will need to
     * pass it the LTI tool or platform that created the JWS so it can grab the
     * correct RSA key needed to verify the siganture. This will also require
     * the expected value for aud and iss. There's 3 parts to the security
     * verification: signature, timestamps, and nonce.
     *
     * Nonce can be stored under 'nonce' or 'jti', so separate methods must be
     * called to verify them: checkJti() or checkNonce()
     */
    public function verifyAndDecode(AbstractLtiEntity $ltiEntity): array
    {
        try {
            $kid = $this->getKid();
            $this->ltiLog->debug('signature verify kid: ' . $kid);
            $key = $ltiEntity->getKey($this->getKid());
            JwsUtil::load($this->token, $key);
            $this->checker->checkTimestamps();
        } catch(\Exception $e) { // invalid signature throws a bare Exception
            throw new LtiException($this->ltiLog->msg('Invalid JWS',$e), 0, $e);
        }
        return $this->claims;
    }

    /**
     * Checks that a claim has the expected value.
     *
     * @throw LtiException if claim doesn't have expected value.
     */
    public function checkClaim(string $param, string $expected): void
    {
        $val = $this->getClaim($param);
        if (is_array($val)) {
            if (!in_array($expected, $val)) {
                $valStr = print_r($val, true);
                throw new LtiException(
                    $this->ltiLog->msg("Claim '$param': '$valStr' doesn't have '$expected'."));
            }
        }
        elseif ($val != $expected) {
            throw new LtiException(
                $this->ltiLog->msg("Claim '$param': '$val' doesn't match expected '$expected'."));
        }
    }

    public function checkIssAndAud(string $expectedIss, string $expectedAud)
    {
        $this->checkClaim(Param::ISS, $expectedIss);
        $this->checkClaim(Param::AUD, $expectedAud);
    }

    /**
     * Check that JTI hasn't been replayed
     *
     * @param $reqStorage - Set to true if if JTI wasn't generated by the shim,
     * we'll need to try adding it to to the nonce store first
     */
    public function checkJti(bool $reqStorage=false): void
    {
        $jti = $this->getClaim(Param::JTI);
        if ($reqStorage) $this->storeNonce($jti);
        $this->checker->checkJti();
    }

    /**
     * Check that nonce hasn't been replayed
     *
     * @param $reqStorage - Set to true if if nonce wasn't generated by the
     * shim, we'll need to try adding it to to the nonce store first
     */
    public function checkNonce(bool $reqStorage=false): void
    {
        $nonce = $this->getClaim(Param::NONCE);
        if ($reqStorage) $this->storeNonce($nonce);
        $this->checker->checkNonce();
    }

    private function storeNonce(string $nonce): void
    {
        Nonce::store($nonce,
            ($this->getClaim(Param::EXP) + Param::TOKEN_LEEWAY) - time());
    }
}
