<?php
namespace UBC\LTI\Specs\Launch;

use Illuminate\Support\Facades\Log;
use Illuminate\Http\Request;

use Jose\Component\Checker\InvalidClaimException;
use Jose\Easy\Build;
use Jose\Easy\JWT;
use Jose\Easy\Load;

use App\Models\Platform;
use App\Models\PlatformClient;
use App\Models\Tool;

use UBC\LTI\LTIException;
use UBC\LTI\Param;
use UBC\LTI\Specs\ParamChecker;

// we're acting as the Tool
// the main idea is that we supply this object with the params that we receive
// and get the appropriate response params back
class ToolLaunch
{
    private Request $request; // laravel request object
    private ParamChecker $checker;

    private bool $hasLogin = false; // true if checkLogin() passed
    private Platform $platform;

    public function __construct(Request $request)
    {
        $this->request = $request;
        $this->checker = new ParamChecker($request->input());
    }

    // first stage of the LTI launch on the tool side, we need to check that
    // the platform has sent us all the information we need
    public function checkLogin()
    {
        $requiredParams = [
            Param::ISS,
            Param::LOGIN_HINT,
            Param::TARGET_LINK_URI
        ];
        $this->checker->requireParams($requiredParams);

        // check that the request is coming from a platform we know
        $iss = $this->request->input(Param::ISS);
        $platform = Platform::where(Param::ISS, $iss)->first();
        if (!$platform) throw new LTIException("Unknown platform iss: $iss");
        $this->platform = $platform;
        // make sure that target_link_uri is pointing to us
        $target = $this->request->input(Param::TARGET_LINK_URI);
        if (strpos($target, config('app.url')) !== 0)
            throw new LTIException("target_link_uri is some other site: $target");

        $this->hasLogin = true;
    }

    // second stage of LTI launch on the tool side, we need to send an auth
    // request back to the platform, this function returns the params that
    // should be sent
    public function getLoginResponse(): array
    {
        $ownTool = Tool::getOwnTool();
        // cannot generate the login response if we don't have a valid login
        if (!$this->hasLogin) $this->checkLogin();
        $resp = [
            Param::SCOPE => Param::OPENID,
            Param::RESPONSE_TYPE => Param::ID_TOKEN,
            Param::LOGIN_HINT => $this->request->input(Param::LOGIN_HINT),
            Param::RESPONSE_TYPE => Param::FORM_POST,
            Param::PROMPT => Param::NONE,
            Param::REDIRECT_URI => $ownTool->auth_resp_url
        ];
        // client_id is either given in the request or stored in the database
        if ($this->request->filled(Param::CLIENT_ID)) {
            $resp[Param::CLIENT_ID] = $this->request->input(Param::CLIENT_ID);
            // TODO: if this is an unknown client_id, should we add it to the
            // list of known client_id?
        } else {
            $iss = $this->request->input(Param::ISS);
            $client = PlatformClient::where('platform_id', $this->platform->id)
                ->first();
            if (!$client) throw new LTIException("No client_id found for $iss");
            $resp[Param::CLIENT_ID] = $client->client_id;
        }
        // lti_message_hint needs to be passed as is back to the platform
        if ($this->request->filled(Param::LTI_MESSAGE_HINT)) {
            $resp[Param::LTI_MESSAGE_HINT] =
                $this->request->input(Param::LTI_MESSAGE_HINT);
        }

        // storing values into state reduces the amount of bookkeeping we need
        // to do on our side, so I'm putting values that requires verification
        // against the id_token into the state. To guarantee that the state was
        // generated by us, I'm using the same kind of signed JWT that LTI use
        $resp[Param::STATE] = $this->createState();

        // TODO: real nonce security
        $resp[Param::NONCE] = 'fakenonce';

        return $resp;
    }

    // third stage of the LTI launch on the tool side, we need to check the
    // authentication response sent back by the platform
    public function checkAuth()
    {
        $requiredParams = [
            Param::STATE,
            Param::ID_TOKEN
        ];
        $this->checker->requireParams($requiredParams);
        $state = $this->checkState($this->request->input(Param::STATE));
        $idToken = $this->checkIdToken($this->request->input(Param::ID_TOKEN),
                                       $state);

        // pass data over to the PlatformLaunch using sessions
        // Laravel session automatically split on periods to create a
        // multi-dimensional array, so the lti uri keys in id_token gets split
        // into subarrays. This makes it hard to look up by uri keys, so
        // instead we're storing the id_token in the original serialized form.
        session([
            'original_iss' => $state->claims->get('original_iss'),
            Param::LOGIN_HINT => $state->claims->get(Param::LOGIN_HINT),
            Param::ID_TOKEN => $this->request->input(Param::ID_TOKEN)
        ]);
    }

    // verify the signature & params in the id_token
    private function checkIdToken(string $token, JWT $state): JWT
    {
        $platform = Platform::firstWhere(Param::ISS,
                                         $state->claims->get('original_iss'));
        $jwk = $platform->keys()->first()->public_key;
        $jwt;
        try {
            $jwt = Load::jws($token);
        } catch(InvalidArgumentException $e) {
            throw new LTIException('id_token not base64 encoded.', 0, $e);
        }
        $jwt = $jwt->algs([Param::RS256]) // The algorithms allowed to be used
                   ->exp() // We check the "exp" claim
                   ->iat(5000) // We check the "iat" claim. Leeway is 5000ms
                   ->aud($state->claims->get(Param::CLIENT_ID))
                   ->iss($state->claims->get('original_iss'))
                   ->key($jwk); // Key used to verify the signature
        try {
            // check signature
            $jwt = $jwt->run();
            // check required claims
            $requiredValues = [
                Param::MESSAGE_TYPE_URI => 'LtiResourceLinkRequest',
                Param::VERSION_URI => '1.3.0'
            ];
            if ($state->claims->has(Param::LTI_DEPLOYMENT_ID)) {
                $requireValues[Param::DEPLOYMENT_ID_URI] =
                    $state->claims->get(Param::LTI_DEPLOYMENT_ID);
            }
            $checker = new ParamChecker($jwt->claims->all());
            $checker->requireValues($requiredValues);
        } catch(\Exception $e) { // invalid signature throws a bare Exception
            throw new LTIException('Invalid id_token: '.$e->getMessage(),0,$e);
        }

        return $jwt;
    }

    // verify the signature on state and return the JWT, throws LTIException if
    // signature could not be verified
    private function checkState(string $token): JWT
    {
        $myPublicKey = Tool::getOwnTool()->keys()->first()->public_key;
        $jwt;
        try {
            $jwt = Load::jws($token);
        } catch(InvalidArgumentException $e) {
            throw new LTIException('Unrecognized state in auth response.', 0, $e);
        }
        $jwt = $jwt->algs([Param::RS256]) // The algorithms allowed to be used
                   ->exp() // We check the "exp" claim
                   ->iat(5000) // We check the "iat" claim. Leeway is 5000ms
                   ->iss(config('lti.iss'))
                   ->key($myPublicKey);
        try {
            $jwt = $jwt->run();
            $requiredParams = ['original_iss', Param::CLIENT_ID,
                               Param::LOGIN_HINT];
            $checker = new ParamChecker($jwt->claims->all());
            $checker->requireParams($requiredParams);
        } catch(\Exception $e) {
            throw new LTIException('Invalid state in auth response: ' .
                $e->getMessage(), 0, $e);
        }
        return $jwt;
    }

    // create a JWT storing params that we expect to also see in id_token
    private function createState(): string
    {
        $myPrivateKey = Tool::getOwnTool()->keys()->first()->key;
        $time = time();
        // TODO: store login_hint for checking against the id_token
        // TODO: store lti_deployment_id for checking against the id_token
        $jws = Build::jws()
            ->exp($time + 3600)
            ->iat($time)
            ->alg(Param::RS256)
            ->iss(config('lti.iss'))
            ->claim('original_iss', $this->request->input(Param::ISS))
            ->claim(Param::CLIENT_ID, $this->request->input(Param::CLIENT_ID))
            ->claim(Param::LOGIN_HINT, $this->request->input(Param::LOGIN_HINT));
        if ($this->request->has(Param::LTI_DEPLOYMENT_ID)) {
            $jws = $jws->claim(Param::LTI_DEPLOYMENT_ID,
                               $this->request->input(Param::LTI_DEPLOYMENT_ID));
        }
        $jws = $jws->sign($myPrivateKey);
        return $jws;
    }
}
